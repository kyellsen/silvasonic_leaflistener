{% extends base %} {% block content %}
<h2
  class="text-xl font-bold mb-4 text-purple-600 dark:text-purple-400 flex items-center gap-2"
>
  <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path
      stroke-linecap="round"
      stroke-linejoin="round"
      stroke-width="2"
      d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z"
    ></path>
  </svg>
  Livesound Stream
</h2>

<div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
  <!-- Main Player Card -->
  <div
    class="lg:col-span-2 bg-white dark:bg-gray-800 rounded-xl shadow-lg border border-gray-200 dark:border-gray-700 overflow-hidden"
  >
    <div class="p-6">
      <h3 class="font-bold text-lg text-gray-700 dark:text-gray-300 mb-4">
        Live Audio & Spectrogram
      </h3>

      <!-- Audio Player -->
      <div
        class="mb-6 bg-gray-100 dark:bg-gray-900 rounded-lg p-4 flex items-center justify-between"
      >
        <div class="flex items-center gap-4">
          <button
            id="playButton"
            class="w-12 h-12 flex items-center justify-center rounded-full bg-purple-600 hover:bg-purple-700 text-white transition-colors"
          >
            <svg
              class="w-6 h-6"
              fill="currentColor"
              viewBox="0 0 24 24"
              id="playIcon"
            >
              <path d="M8 5v14l11-7z" />
            </svg>
            <svg
              class="w-6 h-6 hidden"
              fill="currentColor"
              viewBox="0 0 24 24"
              id="pauseIcon"
            >
              <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z" />
            </svg>
          </button>
          <div>
            <div class="text-sm font-bold text-gray-900 dark:text-gray-100">
              Live Stream
            </div>
            <div class="text-xs text-gray-500 font-mono" id="statusText">
              Connecting...
            </div>
          </div>
        </div>

        <div class="text-xs text-gray-400 host-info">
          Host: <span class="font-mono" id="hostLabel">port 8000</span>
        </div>
      </div>

      <!-- Spectrogram Canvas -->
      <div
        class="relative w-full h-64 bg-black rounded-lg overflow-hidden ring-1 ring-gray-900/5"
      >
        <canvas id="spectrogramCanvas" class="w-full h-full"></canvas>
        <div
          class="absolute top-2 right-2 text-xs text-white/50 bg-black/50 px-2 py-1 rounded"
        >
          Live FFT
        </div>
      </div>
    </div>
  </div>

  <!-- Info / Controls -->
  <div
    class="bg-white dark:bg-gray-800 rounded-xl shadow-lg border border-gray-200 dark:border-gray-700 p-6"
  >
    <h3 class="font-bold text-lg text-gray-700 dark:text-gray-300 mb-4">
      Stream Settings
    </h3>

    <div class="space-y-4">
      <!-- Source Selector -->
      <div>
        <label
          for="sourceSelect"
          class="block text-xs font-bold text-gray-500 uppercase mb-1"
          >Microphone Source</label
        >
        <select
          id="sourceSelect"
          class="w-full bg-gray-50 dark:bg-gray-900 border border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white text-sm rounded-lg focus:ring-purple-500 focus:border-purple-500 block p-2.5"
        >
          <option
            value="default"
            {%
            if
            not
            recorder_stats
            %}selected{%
            endif
            %}
          >
            Default (Auto)
          </option>
          {% for stat in recorder_stats %} {% set p = stat.profile if
          stat.profile is mapping else {} %} {% set slug = p.slug or 'default'
          %} {% set name = p.name or ('Recorder ' + loop.index|string) %}
          <option value="{{ slug }}" {% if loop.first %}selected{% endif %}>
            {{ name }} ({{ slug }})
          </option>
          {% endfor %}
        </select>
        <p class="text-[10px] text-gray-400 mt-1">Select input to stream.</p>
      </div>

      <div
        class="flex justify-between items-center py-2 border-b border-gray-100 dark:border-gray-700"
      >
        <span class="text-sm text-gray-500">Status</span>
        <span
          class="px-2 py-1 rounded text-xs font-bold bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200"
          id="connectionStatus"
        >
          Online
        </span>
      </div>
      <div
        class="flex justify-between items-center py-2 border-b border-gray-100 dark:border-gray-700"
      >
        <span class="text-sm text-gray-500">Latency</span>
        <span class="text-sm font-mono text-gray-700 dark:text-gray-300"
          >~200ms</span
        >
      </div>

      <div class="mt-6 pt-4">
        <div class="text-xs text-gray-400 mb-2">Volume</div>
        <input
          type="range"
          id="volumeSlider"
          min="0"
          max="1"
          step="0.1"
          value="1"
          class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700"
        />
      </div>
    </div>
  </div>
</div>

<script>
  /*
   * Livesound Lifecycle Management (Client-Side Only)
   * Uses Web Audio API to visualize Icecast stream
   */
  (function () {
    // --- State ---
    const state = {
      audioCtx: null,
      analyser: null,
      sourceNode: null,
      audioEl: new Audio(),
      currentSource: document.getElementById("sourceSelect")
        ? document.getElementById("sourceSelect").value
        : "default",
      streamBaseUrl: `${window.location.protocol === "https:" ? "https" : "http"}://${window.location.hostname}:80/stream/live`, 
      canvas: document.getElementById("spectrogramCanvas"),
      ctx: null,
      tempCanvas: document.createElement("canvas"),
      tempCtx: null,
      isActive: true,
      dataArray: null,
      animationId: null,
    };

    // --- DOM Elements ---
    const ui = {
      playBtn: document.getElementById("playButton"),
      playIcon: document.getElementById("playIcon"),
      pauseIcon: document.getElementById("pauseIcon"),
      status: document.getElementById("statusText"),
      vol: document.getElementById("volumeSlider"),
      connStatus: document.getElementById("connectionStatus"),
      hostLabel: document.getElementById("hostLabel"),
      sourceSelect: document.getElementById("sourceSelect"),
    };

    // --- Helpers ---
    function setStatus(text, type) {
      if (!ui.status) return;
      ui.status.innerText = text;
      ui.status.className = "text-xs font-mono";

      switch (type) {
        case "success":
          ui.status.classList.add("text-green-500");
          break;
        case "error":
          ui.status.classList.add("text-red-500", "font-bold");
          break;
        case "warning":
          ui.status.classList.add("text-yellow-600", "dark:text-yellow-400");
          break;
        default:
          ui.status.classList.add("text-gray-500", "dark:text-gray-400");
      }
    }

    function getStreamUrl() {
        // Icecast Mountpoint (Assuming single mount /live for now, per prompt)
        // If we want multiple mounts, we'd append _slug
        // For simplicity: hardcode to /stream/live (proxied to /live)
        return `${state.streamBaseUrl}`;
    }

    // --- Initialization ---
    function init() {
      console.log("[Livesound] Initializing Client-Side Spectrogram...");

      if (ui.hostLabel) {
        ui.hostLabel.innerText = "Icecast Stream";
      }

      state.audioEl.crossOrigin = "anonymous";

      if (state.canvas) {
        state.ctx = state.canvas.getContext("2d");
        state.tempCtx = state.tempCanvas.getContext("2d");
        resizeCanvas();
        window.addEventListener("resize", resizeCanvas);
      }

      setupAudioListeners();
      setupUIListeners();

      document.body.addEventListener("htmx:beforeSwap", cleanup, {
        once: true,
      });
      
      setStatus("Ready", "neutral");
    }

    // --- Audio Context Setup ---
    function initAudioContext() {
        if (state.audioCtx) return;

        const AudioContext = window.AudioContext || window.webkitAudioContext;
        state.audioCtx = new AudioContext();
        
        state.analyser = state.audioCtx.createAnalyser();
        state.analyser.fftSize = 1024; // Resolution
        state.analyser.smoothingTimeConstant = 0.5;

        state.sourceNode = state.audioCtx.createMediaElementSource(state.audioEl);
        state.sourceNode.connect(state.analyser);
        state.analyser.connect(state.audioCtx.destination);

        const bufferLength = state.analyser.frequencyBinCount;
        state.dataArray = new Uint8Array(bufferLength);
    }

    // --- Cleanup ---
    function cleanup(event) {
      console.log("[Livesound] Cleaning up...");
      state.isActive = false;
      stopStream();
      if (state.audioCtx) {
        state.audioCtx.close();
      }
      if (state.animationId) {
          cancelAnimationFrame(state.animationId);
      }
      window.removeEventListener("resize", resizeCanvas);
    }


    // --- Audio Control ---
    function startStream() {
      setStatus(`Connecting...`, "warning");

      if (!state.audioCtx) {
          initAudioContext();
      }
      if (state.audioCtx.state === 'suspended') {
          state.audioCtx.resume();
      }

      const streamUrl = getStreamUrl();
      if (state.audioEl.src !== streamUrl) {
           state.audioEl.src = streamUrl;
      }
      
      state.audioEl.play().catch((e) => {
        console.error("Play failed:", e);
        setStatus("Autoplay Blocked", "error");
      });

      drawLoop();
    }

    function stopStream() {
      state.audioEl.pause();
      state.audioEl.src = "";
      state.audioEl.load();
      setStatus("Stopped", "neutral");
      updateUI(false);
      if (state.animationId) {
          cancelAnimationFrame(state.animationId);
      }
    }

    // --- Visualizer Loop ---
    function drawLoop() {
        if (!state.isActive) return;
        state.animationId = requestAnimationFrame(drawLoop);

        if (!state.analyser) return;

        state.analyser.getByteFrequencyData(state.dataArray);
        drawSpectrogramColumn(state.dataArray);
    }

    // --- Spectrogram Drawing ---
    function drawSpectrogramColumn(dataArray) {
      if (!state.ctx) return;
      const w = state.canvas.width;
      const h = state.canvas.height;

      // 1. Shift
      state.tempCanvas.width = w;
      state.tempCanvas.height = h;
      state.tempCtx.drawImage(state.canvas, 0, 0);
      state.ctx.clearRect(0, 0, w, h);
      state.ctx.drawImage(state.tempCanvas, -1, 0);

      // 2. Draw Column (at right edge)
      // Map FFT bins to Y axis (0 to h)
      // Logarithmic scale often looks better for audio, but linear is simpler for now.
      // We only care about up to ~20kHz.
      // dataArray length = 512 (fftSize/2). 48kHz / 2 = 24kHz. Perfect.

      const binHeight = h / dataArray.length;
      
      for (let i = 0; i < dataArray.length; i++) {
        const value = dataArray[i]; // 0-255
        if (value < 10) continue; // Noise gate

        const hue = 260 - (value / 255) * 200; // Blue to Red
        const light = (value / 255) * 50;
        
        state.ctx.fillStyle = `hsl(${hue}, 100%, ${light}%)`;
        // Invert Y: 0Hz at bottom
        const y = h - (i * binHeight);
        state.ctx.fillRect(w - 1, y, 1, binHeight + 1);
      }
    }

    function resizeCanvas() {
      if (state.canvas) {
        state.canvas.width = state.canvas.offsetWidth;
        state.canvas.height = state.canvas.offsetHeight;
      }
    }

    // --- Event Wiring ---
    function setupAudioListeners() {
      state.audioEl.addEventListener("play", () => updateUI(true));
      state.audioEl.addEventListener("pause", () => updateUI(false));

      state.audioEl.addEventListener("playing", () => {
        setStatus("Live Audio", "success");
        ui.connStatus.innerText = "Online";
      });
      state.audioEl.addEventListener("waiting", () =>
        setStatus("Buffering...", "warning"),
      );
      state.audioEl.addEventListener("error", (e) => {
        updateUI(false);
        setStatus("Stream Error", "error");
      });
      state.audioEl.addEventListener("ended", () => {
        updateUI(false);
        setStatus("Stream Ended", "neutral");
      });
    }

    function setupUIListeners() {
      ui.playBtn.onclick = () => {
        if (state.audioEl.paused) startStream();
        else stopStream();
      };

      ui.vol.oninput = (e) => {
        const v = parseFloat(e.target.value);
        if (!isNaN(v)) state.audioEl.volume = v;
      };

      // Source select just restarts the stream (if multiple mounts supported later)
      ui.sourceSelect.onchange = (e) => {
          if (!state.audioEl.paused) {
            stopStream();
            setTimeout(startStream, 500);
          }
      };
    }

    function updateUI(isPlaying) {
      if (isPlaying) {
        ui.playIcon.classList.add("hidden");
        ui.pauseIcon.classList.remove("hidden");
        ui.playBtn.classList.replace("bg-purple-600", "bg-red-500");
        ui.playBtn.classList.replace("hover:bg-purple-700", "hover:bg-red-600");
      } else {
        ui.playIcon.classList.remove("hidden");
        ui.pauseIcon.classList.add("hidden");
        ui.playBtn.classList.replace("bg-red-500", "bg-purple-600");
        ui.playBtn.classList.replace("hover:bg-red-600", "hover:bg-purple-700");
      }
    }

    init();
  })();
</script>
{% endblock %} {% block inspector %}
<div id="inspector-content" hx-swap-oob="innerHTML:#inspector-content">
  <!-- No inspector needed for live stream page -->
</div>
{% endblock %}
