# ðŸŒ² Silvasonic 2.0: Target Architecture Concept

> **Status:** Final Concept / Target Architecture
> **Design Principle:** "Record First, Analyze Later" â€” Data integrity is paramount.

This document defines the consolidated architecture for Silvasonic. It serves as the single source of truth for the system's target state.

## 1. Core Philosophy & Data Strategy

The file system (NVMe) is the "Single Source of Truth" for raw data. The Database is the index and state engine.

### Data Storage Strategy
| Type | Format | Location | Retention | Purpose |
|------|--------|----------|-----------|---------|
| **Raw Capture** | `.wav` (PCM) | Local NVMe (`/data`) | Rolling Buffer | **Stability.** Writing WAV is CPU-cheap (DMA). No risk of dropouts during load spikes. |
| **Archive** | `.flac` | Cloud Storage | Permanent | **Efficiency.** Compressed (approx. 50% savings) locally by the Uploader *before* transfer. |
| **Analysis** | `.wav` | Local NVMe | Until Cleanup | **Speed.** Decoding FLAC for inference costs CPU; mapping WAV is instant. |

### Dual-Stream Recording
To optimize for both Bats (High-Res) and Birds/Web (Low-Res) without live downsampling during playback:
1.  **Source:** 384kHz Microphone.
2.  **Recorder Action:** Splits signal immediately via `ffmpeg`:
    *   **Stream A (Archive):** Writes 384kHz `.wav` to `/data/recordings/{id}/high_res/` (For Bats & Archive).
    *   **Stream B (Analysis):** Resamples to 48kHz `.wav` to `/data/recordings/{id}/low_res/` (For BirdNET & Web-Playback).

    > **Sweet Spot Strategy:**
    > *   **Local:** pure WAV. No CPU overhead for decoding during analysis (BirdNET/BatDetect). Storage on NVMe is cheap/fast.
    > *   **Cloud:** Uploader converts Stream A (384k WAV) -> FLAC on the fly. Trades one-time CPU (encoding) for 50% bandwidth/cloud-storage savings.

    > *   **Local:** pure WAV. No CPU overhead for decoding during analysis (BirdNET/BatDetect). Storage on NVMe is cheap/fast.
    > *   **Cloud:** Uploader converts Stream A (384k WAV) -> FLAC on the fly. Trades one-time CPU (encoding) for 50% bandwidth/cloud-storage savings.

---

## 2. Technical Standards (Mandatory)

To ensure long-term maintainability and stability, all containers must adhere to these rules:

1.  **Dependency Management:**
    *   **MUST** use `pyproject.toml`.
    *   **MUST** use `uv` for package installation (fast, reliable locking).
    *   **NO** `requirements.txt` (unless generated by uv for build).
2.  **Code Quality:**
    *   **MUST** use `pydantic` for data validation and models.
    *   **MUST** use strict typing (`mypy` compatible).
3.  **State & Status:**
    *   **MUST** use **Redis** for live status/heartbeats.
    *   **MUST** use **TimescaleDB** for persistent data (Recordings, Measurements, Detections).
    *   **BAN:** No writing JSON status files to disk (Legacy "Status File" pattern is deprecated).
4.  **Configuration:**
    *   `settings.json` (Global) or `config.yaml` (Service-specific) permitted.
    *   Environment Variables override files.
5.  **Frontend/Dashboard:**
    *   **MUST NOT** read the filesystem directly to list recordings.
    *   **MUST** query the Database for all lists/history.

6.  **Resilience & Queueing:**
    *   **Strategy:** "Crash or Redis".
    *   **Queueing:** Use **Redis Lists** for buffering jobs if the DB is busy.
    *   **Outage:** If the Main Database is offline, the service MUST **QUEUE in Redis** or **CRASH** (allowing Podman/Systemd to handle Crash-Loop-Backoff).
    *   **BAN:** Do NOT use local SQLite databases for queueing/buffering (Over-engineering). "Record First" guarantees raw WAVs are safe; metadata can wait.

---

## 3. Infrastructure Strategy (Rootless)

**Decision:** The system ALWAYS runs **Rootless** (User: `pi`).
**Reasoning:** While security is a plus, the primary driver is **File Ownership**. Running rootless ensures recordings are owned by `pi`, allowing easy management via SFTP/Explorer without permission errors.

### Mandatory Host Configuration
1.  **Groups:** The user `pi` MUST be in: `audio`, `plugdev`, `video`, `dialout`, `gpio`.
2.  **Ports:** `sysctl -w net.ipv4.ip_unprivileged_port_start=80` (Allows Caddy to bind Port 80).
3.  **Linger:** `loginctl enable-linger pi` (Ensures containers start without login).
4.  **Service:** Systemd runs as User Unit (`systemctl --user enable silvasonic`).

### Controller "Superpowers"
The `silvasonic_controller` acts as the Privileged Proxy:
*   **Privileged:** `true` (to see Host Devices).
*   **Group Add:** Mounts host groups (`--group-add keep-groups`) to pass permissions to Recorders.

---

## 4. Container Architecture

All containers are prefixed with `silvasonic_`.

### A. Container Management Strategy (Hybrid)

To balance **stability** and **control**, we split the stack:

1.  **Infrastructure Tier (Managed by Podman Compose / Systemd):**
    *   These components are critical dependencies. If they die, the Controller dies. They must start *before* the Controller.
    *   *Components:* `gateway`, `database`, `redis`, `tailscale`, and the `controller` itself.

2.  **Application Tier (Managed by Controller):**
    *   These components contain logic that might need restarts, updates, or scaling triggered by the user via the Dashboard.
    *   *Components:* `dashboard`, `monitor`, `livesound` (optional), `weather`, `uploader`, `recorders` (dynamic).
    *   *Benefit:* User can click "Restart Dashboard" in the Web UI without SSH access.

### B. Infrastructure (Static / Root Layer)

#### 1. `silvasonic_gateway` (Reverse Proxy)
*   **Tech:** **Caddy** (Alpine).
*   **Role:** Single entry point (Port 80/443).
*   **Configuration:**
    *   Auto-HTTPS management.
    *   Routes `/` -> `dashboard`.
    *   Routes `/stream` -> `livesound` (optional) or static files.
    *   Secures access via Basic Auth (if not handled by Dashboard).

#### 2. `silvasonic_database` (Persistence)
*   **Tech:** **TimescaleDB** (PostgreSQL 16 base).
*   **Role:** Central State & Index.
*   **Configuration:** Optimized for Raspberry Pi 5 + NVMe.
    *   `synchronous_commit = off` (Speed > Safety).
    *   `shared_buffers = 512MB` (12% of 4GB RAM).
    *   `random_page_cost = 1.1` (NVMe tuning).
*   **Schema:** `recordings` hypertable partitioned by time.
*   **Key Fields:** `device_id`, `analyzed_bird` (bool), `analyzed_bat` (bool), `uploaded` (bool).
*   **Service State:** Table `service_state` stores user preferences (e.g., `birdnet_enabled=true`).
*   **Initialization:** `containers/db/init/*.sql`.
    *   **Mandatory:** Must define `recordings` and `detections` tables and execute `create_hypertable()`.
    *   **Current Status:** Missing in codebase (only exists in prompts). Needs implementation.
*   **Extensions:** PostGIS (optional for maps), TimescaleDB.
*   **Job Queue (Implicit):** Usage of boolean flags (`analyzed_bird`, `analyzed_bat`, `uploaded`) serves as a persistent work queue.

#### 3. `silvasonic_redis` (Messaging)
*   **Tech:** **Redis** (Alpine).
*   **Role:** Real-time glue.
*   **Data:**
    *   Live Meters (VU-Meter values).
    *   System Health Heartbeats (`status:container:heartbeat`).
    *   Job Queues (if simple DB pulling isn't enough).

#### 4. `silvasonic_livesound` (Streaming Server)
*   **Tier:** Infrastructure (Managed by Compose).
*   **Image:** `icecast:alpine` (Official Image).
*   **Role:** Robust Audio Relay.
*   **Source Code:** **NONE.** (Legacy Python code is obsolete).
*   **Flow:** Recorder (`ffmpeg`) -> Icecast Mountpoint -> Browser (`<audio>`).
*   **Format:** MP3 (320kbps) or Opus.
*   **Rationale:** Standard, stable, compatible.

#### 5. `silvasonic_tailscale` (Remote Access)
*   **Tech:** Official Tailscale Image.
*   **Role:** Secure VPN mesh networking.
*   **Features:**
    *   Exposes the dashboard to the authorized Tailnet.
    *   No public ports opened on the router.

#### 5. `silvasonic.service` (Systemd Bootloader)
*   **Type:** Systemd Unit File.
*   **Role:** The "Big Bang".
*   **Command:** `podman-compose up -d` (Infrastructure Only).
*   **Behavior:** Starts Gateway, DB, Redis, Controller on boot.
*   **Resiliency:** `Restart=always` ensures base infra stays up.

### C. Core Loop Services

#### 5. `silvasonic_controller` (Hardware Manager)
*   **Security:** **PRIVILEGED** (Root/Socket Access).
*   **Role:** Infrastructure & Container Supervisor.
*   **Mechanism:** Runs privileged to access `/dev/bus/usb`, but spawns Recorders using the Host User's GID (Rootless-compatible).
*   **Tasks:**
    *   **Hot-Plug:** Udev monitoring -> Spawns `recorder` containers.
    *   **Service Supervision:** Starts/Stops App containers (`birdnet`, `livesound`) based on `service_state`.
    *   **Capabilities:** Needs access to `/dev/bus/usb` and `/run/podman/podman.sock`.
    *   **Constraint:** **NO** File processing. **NO** Database logic (except minimal config reading). If this crashes, recording continues, but new mics won't appear.

#### 6. `silvasonic_processor` (The Brain)
*   **Security:** **UNPRIVILEGED** (User Mode).
*   **Tech:** Python.
*   **Role:** Data Logic & Indexing. Local File Lifecycle Manager.
*   **Modules:**
    *   **Indexer (The "Eye"):** Scans `/data/recordings/` for new files. Inserts into DB.
    *   **Thumbnailer:** Generates static Spectrogram PNGs for 384kHz files (Bat visualization) via `librosa`/`matplotlib`.
    *   **Coordinator:** Manages metadata logic.
    *   **Notification Dispatch:** **Publishes** JSON Alert to Redis `alerts` channel (No Apprise logic here).
    *   **Janitor:** The cleanup crew.
        *   *Check Interval:* Every 5 min.
        *   *Thresholds:*
            *   Safety: Keep > 20% free space.
            *   Warning (>80% full): Delete `uploaded=true` (Oldest first).
            *   Critical (>90% full): Delete *any* oldest files.
    *   **Constraint:** If this crashes, the System is stable, just "dumb" (no indexing).

#### 7. `silvasonic_birdnet` (Analysis Worker)
*   **Tech:** Python `birdnet_analyzer`.
*   **Role:** Worker.
*   **Input:** Polls DB: `SELECT path FROM recordings WHERE analyzed_bird=false`.
*   **Action:** Reads file -> Analyzes -> Updates DB (`analyzed_bird=true`) + Publishes Alert to Redis.
*   **Benefit:** Zero race conditions. Easy Reprocessing ("Reset Flag in DB").

#### 8. `silvasonic_monitor` (Watchdog)
*   **Tech:** Python (Standalone Loop).
*   **Role:** System health & Notifications.
*   **Input:**
    *   **Monitor:** Scans Redis keys `status:*` (Heartbeats).
    *   **Errors:** Checks for service failures.
    *   **Events:** Subscribes to Redis Channel `alerts`.
*   **Output:** **SOLE Dispatcher** for Apprise (Email, Telegram, Gotify). Reads `settings.json` for secrets.
*   **Logic:** Timeout detection and Event forwarding.
*   **Note:** Unified service (formerly healthchecker).

#### 9. `silvasonic_uploader` (Cloud Sync)
*   **Tech:** Python wrapping **rclone**.
*   **Role:** Independent process for data exfiltration.
*   **Strategy:** "Nice" priority (CPU low).
*   **Logic:**
    *   Queries `recordings WHERE uploaded=false`.
    *   Converts High-Res WAV -> FLAC (temp).
    *   Uploads FLAC via `rclone` (S3/WebDAV/Nextcloud).
    *   Updates DB `uploaded=true`.
    *   Deletes temp FLAC.

### D. Analysis Workers

#### 10. `silvasonic_weather` (Meteorologist)
*   **Tech:** Python (Schedule Loop).
*   **Role:** Environmental Context logger.
*   **Input:** OpenMeteo API (GPS coords from `settings.json`).
*   **Output:** `weather.measurements` DB Table (Temp, Rain, Wind, Cloud Cover).
*   **Frequency:** Every 20 minutes (configurable).
*   **Goal:** Correlate Bat activity with Temp/Rain.

### E. Frontend

#### 11. `silvasonic_dashboard`
*   **Tech Stack:**
    *   **Backend:** **FastAPI**.
    *   **Frontend:** **Jinja2** (Templates) + **HTMX** (Interactivity) + **Alpine.js** (Minimal logic).
    *   **CSS:** **TailwindCSS** (CDN or build step).
*   **Visualization:**
    *   **Plots:** **Plotly.js** (for historical data charts).
    *   **Audio/Spectrogram:** **Wavesurfer.js** (Client-side rendering for 48k). Server-side PNGs for Bats.
*   **Live View:** Polls Redis/DB for status. Images updated via HTMX polling.
*   **Strategy:** Parallel rollout.


---

---

## 5. Database Schema & Data Governance

> **Strategy:** Single Public Schema.
> **Consistency:** All containers MUST import models from `src.shared.database`. No ad-hoc SQL tables allowed.

### Schema Definition
| Table | Owner (Writer) | Readers | Partitioning | Beschreibung |
| :--- | :--- | :--- | :--- | :--- |
| **`recordings`** | `processor` | Alle | Hypertable (Time) | Der zentrale Index aller WAV-Dateien.<br>**Cols:** `id`, `time`, `path_high`, `path_low`, `device_id`, `uploaded` (bool), `analyzed_bird` (bool), `analyzed_bat` (bool). |
| **`detections`** | `analysis_*` | Dashboard | Hypertable (Time) | KI-Ergebnisse (One-to-Many zu Recording).<br>**Cols:** `time`, `recording_id` (FK), `species`, `confidence`, `algorithm` ('birdnet'). |
| **`measurements`** | `weather` | Dashboard | Hypertable (Time) | Umwelt-Kontext.<br>**Cols:** `time`, `temp_c`, `rain_mm`, `wind_kmh`. |
| **`service_state`** | `dashboard` | Controller | None (Relational) | Konfiguration & User-WÃ¼nsche.<br>**Cols:** `service_name` (PK), `enabled` (bool), `params` (JSON). |
| **`devices`** | `controller` | Processor | None (Relational) | Hardware-Inventar.<br>**Cols:** `device_id` (PK), `name`, `hardware_profile`, `last_seen`. |

### Implementation Rules & Lifecycle
1.  **Schema Authority:**
    *   The `init.sql` in the Database container is the **Single Source of Truth** for fresh installs.
    *   Python containers MUST NOT use SQLAlchemy `create_all()` (Prevent Race Conditions).
2.  **Access Control (Logical):**
    *   `processor`: Only service allowed to INSERT into `recordings`.
    *   `uploader`: Only service allowed to UPDATE `uploaded` flag.
    *   `analysis_`: Only services allowed to INSERT into `detections`.
3.  **Automatic Retention (TimescaleDB Feature):**
    *   For `measurements` and `detections` (pure data), we use TimescaleDB native policies:
        *   `SELECT add_retention_policy('measurements', INTERVAL '1 year');`
    *   For `recordings`, we rely on the **Janitor** (due to file dependency).

---

## 6. Resilience & Priority Model

This hierarchy dictates resource allocation (CPU/RAM) and OOM (Out of Memory) killer behavior.
**Principle:** "Analysis MUST die before Recording."

| Level | Containers | Criticality | Resource Strategy |
| :--- | :--- | :--- | :--- |
| **Tier 0 (Vital)** | `db`, `redis`, `gateway`, `controller`, `monitor` | **System Death** if down. | `OOM Score: -1000` (Disable Kill), Unbounded CPU. |
| **Tier 1 (Core)** | `recorder`, `processor` | **Data Loss** if down. | High CPU Priority. `restart: always`. |
| **Tier 2 (Mission)** | `uploader` | **Data Risk** (Backlog/Disk Full). | Medium Priority. Depends on `processor`. |
| **Tier 3 (UX)** | `dashboard` | **Inconvenience**. | Standard. |
| **Tier 4 (Extras)** | `birdnet`, `weather`, `livesound` | **Dispensable**. | **CAPPED CPU/RAM.** `OOM Score: 1000` (Kill First). |

**Implications:**
*   **Cpu Caps:** Analysis workers MUST be strictly capped (e.g., max 50% CPU) to ensure Recording never drops samples.
*   **Dependency Chain:** `uploader` depends on `processor` (for indexing/packaging), reinforcing the Processor's high priority.

---

## 7. Visualization Strategy (The "Hybrid" UX)

The Dashboard distinguishes between audible birds and ultrasonic bats.

### Widget A: "Live Monitor" (48kHz / Birds)
*   **Tech:** **Icecast Stream** + **Web Audio API**.
*   **UX:** Flawless Audio/Visual sync using client-side JS (`Wavesurfer.js` or `Canvas`).
*   **Logic:** Browser decodes audio -> JS AnalyserNode draws live spectrogram.
*   **Limits:** Shows frequencies up to ~22kHz (Audible range).

### Widget B: "Ultrasound Monitor" (384kHz / Bats)
*   **Problem:** Browsers cannot decode or visualize ultrasonic audio (>24kHz).
*   **Solution:** **Server-Side Rendering** (Near-Realtime).
    *   **Backend:** Processor generates a PNG Spectrogram immediately when a 15s chunk is written.
    *   **Frontend:** HTMX polls for the latest image every 15s (`hx-trigger="every 15s"`).
*   **UX:** A "Slideshow" of the latest ultrasonic activity. Silent investigation.

### Centralized Janitor (Cleanup Logic)
*   **Rule:** "Only ONE actor deletes files."
*   **Who:** The `silvasonic_processor` (Background Task).
*   **Logic:** Queries TimescaleDB.
    *   `DELETE FROM recordings WHERE uploaded=true AND analyzed_bird=true AND timestamp < NOW() - INTERVAL '30 days'`
*   **Safety:** Never delete unless `uploaded=true` (if upload strategy is enabled).

### Microphone Profiles (Hardware Abstraction)
*   **Location:** `/app/mic_profiles/*.yml`
*   **Function:** Matches USB Vendor/Product strings to specific configs (Sample Rate, Gain, Channels).
*   **Feature:** Supports "Mock" profiles for testing without hardware.

### Notification System (Redis Pub/Sub)
*   **Architecture:** Event-Driven.
*   **Protocol:** Redis Pub/Sub. Channel: `alerts`.
*   **Format:** JSON `{"type": "alert|info", "title": "...", "body": "...", "tag": "#bat"}`.
*   **Dispatcher:** `silvasonic_monitor` is the **ONLY** service with Apprise config/secrets.
*   **Producers:** `processor`, `birdnet`, etc. just `publish` to Redis.

### Frontend Stack Detail
*   **HTMX:** Used for "Update this div every 2 seconds" (Live Status) and "Load list of recordings" (Infinite Scroll).
*   **Tailwind:** Utility classes for rapid UI. Dark mode default.
*   **Auth:** Basic Auth (Gateway) or Form Auth (FastAPI).

### Janitor Logic (Detailed)
1.    *   **Sync Logic:** "Local WAV -> Remote FLAC". Compresses 384kHz files on the fly before upload to save bandwidth.
    *   **Deduplication:** Uses Rclone to verify state.
    *   **Safe Janitor:** Deletes local files only if `uploaded=true` AND `analyzed=true`. Delete oldest chunk. Repeat.
    *   **Red (<10% free):** Query DB for `uploaded=true`. Delete oldest chunk.
    *   **Panic (<5% free):** DELETE oldest recording regardless of status. Log "DATA LOSS EVENT".

### LiveSound Strategy
*   **Primary:** Dashboard uses "Near Realtime" playback. It auto-loads the most recently *finished* WAV chunk (approx. 15s delay). This uses standard HTTP and is rock solid.
*   **Secondary (On Demand):** If user clicks "Connect Live", the frontend connects to `silvasonic_livesound` (Icecast). Recorder spawns an `ffmpeg` pipe to the Icecast mountpoint.
